Java通过Executors提供四种线程池，分别为：

**newSingleThreadExecutor** 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

**newFixedThreadPool** 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

**newCachedThreadPool **创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程。当新任务添加到线程池，若无空闲线程，则新建线程。

**newScheduledThreadPool** 创建一个定长线程池，支持定时及周期性任务执行。

### 1、newSingleThreadExecutor

创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。示例代码如下：

```
/**
 * 单线程池
 */
private static void newSingleThreadExecutor() {
    ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
    for (int i = 0; i < 10; i++) {
        final int index = i;
        singleThreadExecutor.execute(() -> {
            System.out.println(index + ":" + Thread.currentThread().getId());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    }
}
```
### 2、newFixedThreadPool

创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。示例代码如下：

```
/**
 * 固定大小的线程池
 */
private static void newFixedThreadPool() {
    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(2);
    for (int i = 0; i < 10; i++) {
        final int index = i;
        fixedThreadPool.execute(() -> {
            try {
                System.out.println(index + ":" + Thread.currentThread());
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    }
}
```
因为线程池大小为2，每个任务输出 index 后sleep 2秒，所以每2秒打印2个数字。
定长线程池的大小最好根据系统资源进行设置，如Runtime.getRuntime().availableProcessors()。

### 3、**newCachedThreadPool**

创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。示例代码如下：

```
/**
 * 无限大小的线程池
 */
private static void newCachedThreadPool() {
    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
    for (int i = 0; i < 10; i++) {
        final int index = i;
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        cachedThreadPool.execute(() -> 
                System.out.println(index + ":" + Thread.currentThread()));
    }
}
```
线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。
### 4、newScheduledThreadPool

创建一个定长线程池，支持定时及周期性任务执行。

延迟执行示例代码如下：

```
/**
 * 定时执行的线程池
 */
private static void newScheduledDelayThreadPool() {
    long startTimeMillis = System.currentTimeMillis();
    ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);
    scheduledExecutorService.schedule(() -> System.out.println("delay millis:" + (System.currentTimeMillis() - startTimeMillis)), 
            2, TimeUnit.SECONDS);
}
```
表示延迟2秒执行。
定期执行示例代码如下：

```
/**
 * 定时+循环执行的线程池
 */
private static void newScheduledPeriodThreadPool() {
    ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);
    long startTimeMillis = System.currentTimeMillis();
    scheduledExecutorService.scheduleAtFixedRate(() -> 
            System.out.println("delay millis:" + (System.currentTimeMillis() - startTimeMillis)), 
            1, 2, TimeUnit.SECONDS);
}
```
表示延迟1秒后每2秒执行一次。
